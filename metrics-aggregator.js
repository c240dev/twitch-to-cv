/**
 * Metrics Aggregator - Multi-instance metrics coordination and alerting
 * Aggregates metrics across bot instances and manages alert thresholds
 * 
 * Enhanced Claude Development Protocol v1.4 - Phase 1: Draft Implementation
 */

class MetricsAggregator {
    constructor(redisClient) {
        this.redisClient = redisClient;
        
        // Configuration
        this.config = {
            aggregationIntervalMs: 60000, // Aggregate every minute
            instanceTimeoutMs: 300000, // 5 minute instance timeout
            alertCheckIntervalMs: 30000, // Check alerts every 30 seconds
            maxInstanceHistory: 100, // Keep last 100 aggregations per instance
            instanceId: process.env.INSTANCE_ID || 'bot-001'
        };
        
        // Instance tracking
        this.instanceMetrics = new Map(); // instanceId -> metrics history
        this.activeInstances = new Set();\n        this.lastInstanceActivity = new Map(); // instanceId -> timestamp\n        \n        // Alert configuration and state\n        this.alertThresholds = {\n            latency: { warning: 12, critical: 18 },\n            memory: { warning: 400, critical: 600 },\n            successRate: { warning: 95, critical: 90 },\n            rateLimitBlocks: { warning: 10, critical: 25 }\n        };\n        \n        this.activeAlerts = new Map(); // alertId -> alert object\n        this.alertHistory = [];\n        \n        // Aggregated metrics storage\n        this.aggregatedMetrics = {\n            totalInstances: 0,\n            avgLatency: 0,\n            totalMemoryMB: 0,\n            totalCVCommands: 0,\n            overallSuccessRate: 0,\n            totalRateLimitBlocks: 0,\n            timestamp: Date.now()\n        };\n        \n        this.init();\n    }\n    \n    init() {\n        // Setup Redis subscriber for metrics updates\n        this.setupMetricsSubscriber();\n        \n        // Setup periodic aggregation\n        setInterval(() => {\n            this.performAggregation();\n        }, this.config.aggregationIntervalMs);\n        \n        // Setup alert monitoring\n        setInterval(() => {\n            this.checkAlerts();\n        }, this.config.alertCheckIntervalMs);\n        \n        // Setup instance cleanup\n        setInterval(() => {\n            this.cleanupInactiveInstances();\n        }, this.config.instanceTimeoutMs);\n        \n        console.log('ðŸ“ˆ Metrics Aggregator initialized');\n    }\n    \n    /**\n     * Setup Redis subscriber for metrics events\n     */\n    async setupMetricsSubscriber() {\n        try {\n            // Create subscriber client (Redis requires separate clients for pub/sub)\n            this.redisSubscriber = this.redisClient.duplicate();\n            await this.redisSubscriber.connect();\n            \n            // Subscribe to metrics updates\n            await this.redisSubscriber.subscribe('cv:system:broadcast', (message) => {\n                this.handleMetricsEvent(JSON.parse(message));\n            });\n            \n            console.log('ðŸ“¡ Metrics aggregator subscribed to system broadcasts');\n        } catch (err) {\n            console.error('Metrics subscriber setup error:', err.message);\n        }\n    }\n    \n    /**\n     * Handle incoming metrics events from instances\n     */\n    handleMetricsEvent(event) {\n        if (event.type !== 'metrics_update') return;\n        \n        const { instance, metrics, overhead } = event.data;\n        const timestamp = event.timestamp;\n        \n        // Update instance activity\n        this.lastInstanceActivity.set(instance, timestamp);\n        this.activeInstances.add(instance);\n        \n        // Store instance metrics\n        if (!this.instanceMetrics.has(instance)) {\n            this.instanceMetrics.set(instance, []);\n        }\n        \n        const instanceHistory = this.instanceMetrics.get(instance);\n        instanceHistory.push({\n            metrics,\n            overhead,\n            timestamp\n        });\n        \n        // Limit history size\n        if (instanceHistory.length > this.config.maxInstanceHistory) {\n            instanceHistory.shift();\n        }\n        \n        console.log(`ðŸ“Š Received metrics from ${instance}: latency ${metrics.avgLatency}ms, memory ${metrics.memoryMB}MB`);\n    }\n    \n    /**\n     * Perform cross-instance metrics aggregation\n     */\n    async performAggregation() {\n        try {\n            const aggregated = this.calculateAggregatedMetrics();\n            \n            // Store aggregated metrics in Redis\n            await this.storeAggregatedMetrics(aggregated);\n            \n            // Update internal state\n            this.aggregatedMetrics = aggregated;\n            \n            console.log(`ðŸ“ˆ Aggregated metrics across ${aggregated.totalInstances} instances`);\n        } catch (err) {\n            console.error('Metrics aggregation error:', err.message);\n        }\n    }\n    \n    /**\n     * Calculate aggregated metrics across all active instances\n     */\n    calculateAggregatedMetrics() {\n        const now = Date.now();\n        const recentThreshold = now - (this.config.aggregationIntervalMs * 2); // Last 2 intervals\n        \n        let totalInstances = 0;\n        let totalLatency = 0;\n        let totalMemory = 0;\n        let totalCommands = 0;\n        let totalSuccessRate = 0;\n        let totalBlocks = 0;\n        let latencyCount = 0;\n        let successRateCount = 0;\n        \n        // Aggregate metrics from all active instances\n        for (const [instanceId, history] of this.instanceMetrics.entries()) {\n            // Get most recent metrics from each instance\n            const recentMetrics = history\n                .filter(h => h.timestamp > recentThreshold)\n                .sort((a, b) => b.timestamp - a.timestamp)[0];\n                \n            if (!recentMetrics) continue;\n            \n            totalInstances++;\n            const metrics = recentMetrics.metrics;\n            \n            // Aggregate latency\n            if (metrics.avgLatency) {\n                totalLatency += parseFloat(metrics.avgLatency);\n                latencyCount++;\n            }\n            \n            // Aggregate memory\n            if (metrics.memoryMB) {\n                totalMemory += parseFloat(metrics.memoryMB);\n            }\n            \n            // Aggregate commands\n            if (metrics.cvCommandsPerMinute) {\n                totalCommands += parseInt(metrics.cvCommandsPerMinute);\n            }\n            \n            // Aggregate success rate\n            if (metrics.successRate) {\n                totalSuccessRate += parseFloat(metrics.successRate);\n                successRateCount++;\n            }\n            \n            // Aggregate rate limit blocks\n            if (metrics.rateLimitBlocks) {\n                totalBlocks += parseInt(metrics.rateLimitBlocks);\n            }\n        }\n        \n        return {\n            totalInstances,\n            avgLatency: latencyCount > 0 ? (totalLatency / latencyCount).toFixed(2) : 0,\n            totalMemoryMB: totalMemory.toFixed(1),\n            totalCVCommands: totalCommands,\n            overallSuccessRate: successRateCount > 0 ? (totalSuccessRate / successRateCount).toFixed(1) : 100,\n            totalRateLimitBlocks: totalBlocks,\n            timestamp: now,\n            activeInstances: Array.from(this.activeInstances)\n        };\n    }\n    \n    /**\n     * Store aggregated metrics in Redis\n     */\n    async storeAggregatedMetrics(aggregated) {\n        try {\n            // Store using existing Redis hash pattern\n            await this.redisClient.hSet('metrics:aggregated', {\n                totalInstances: aggregated.totalInstances.toString(),\n                avgLatency: aggregated.avgLatency.toString(),\n                totalMemoryMB: aggregated.totalMemoryMB.toString(),\n                totalCVCommands: aggregated.totalCVCommands.toString(),\n                overallSuccessRate: aggregated.overallSuccessRate.toString(),\n                totalRateLimitBlocks: aggregated.totalRateLimitBlocks.toString(),\n                activeInstances: JSON.stringify(aggregated.activeInstances),\n                lastUpdate: aggregated.timestamp.toString()\n            });\n        } catch (err) {\n            console.error('Aggregated metrics storage error:', err.message);\n        }\n    }\n    \n    /**\n     * Check metrics against alert thresholds\n     */\n    async checkAlerts() {\n        try {\n            const metrics = this.aggregatedMetrics;\n            const newAlerts = [];\n            \n            // Check latency alerts\n            if (metrics.avgLatency > this.alertThresholds.latency.critical) {\n                newAlerts.push(this.createAlert('latency_critical', \n                    `Critical latency: ${metrics.avgLatency}ms (threshold: ${this.alertThresholds.latency.critical}ms)`,\n                    'critical', metrics.avgLatency, this.alertThresholds.latency.critical));\n            } else if (metrics.avgLatency > this.alertThresholds.latency.warning) {\n                newAlerts.push(this.createAlert('latency_warning',\n                    `High latency: ${metrics.avgLatency}ms (threshold: ${this.alertThresholds.latency.warning}ms)`,\n                    'warning', metrics.avgLatency, this.alertThresholds.latency.warning));\n            }\n            \n            // Check memory alerts\n            if (metrics.totalMemoryMB > this.alertThresholds.memory.critical) {\n                newAlerts.push(this.createAlert('memory_critical',\n                    `Critical memory usage: ${metrics.totalMemoryMB}MB (threshold: ${this.alertThresholds.memory.critical}MB)`,\n                    'critical', metrics.totalMemoryMB, this.alertThresholds.memory.critical));\n            } else if (metrics.totalMemoryMB > this.alertThresholds.memory.warning) {\n                newAlerts.push(this.createAlert('memory_warning',\n                    `High memory usage: ${metrics.totalMemoryMB}MB (threshold: ${this.alertThresholds.memory.warning}MB)`,\n                    'warning', metrics.totalMemoryMB, this.alertThresholds.memory.warning));\n            }\n            \n            // Check success rate alerts\n            if (metrics.overallSuccessRate < this.alertThresholds.successRate.critical) {\n                newAlerts.push(this.createAlert('success_rate_critical',\n                    `Critical success rate: ${metrics.overallSuccessRate}% (threshold: ${this.alertThresholds.successRate.critical}%)`,\n                    'critical', metrics.overallSuccessRate, this.alertThresholds.successRate.critical));\n            } else if (metrics.overallSuccessRate < this.alertThresholds.successRate.warning) {\n                newAlerts.push(this.createAlert('success_rate_warning',\n                    `Low success rate: ${metrics.overallSuccessRate}% (threshold: ${this.alertThresholds.successRate.warning}%)`,\n                    'warning', metrics.overallSuccessRate, this.alertThresholds.successRate.warning));\n            }\n            \n            // Process new alerts\n            for (const alert of newAlerts) {\n                await this.processAlert(alert);\n            }\n            \n            // Clean up resolved alerts\n            this.cleanupResolvedAlerts();\n            \n        } catch (err) {\n            console.error('Alert checking error:', err.message);\n        }\n    }\n    \n    /**\n     * Create alert object\n     */\n    createAlert(id, message, severity, currentValue, threshold) {\n        return {\n            id,\n            message,\n            severity,\n            currentValue,\n            threshold,\n            timestamp: Date.now(),\n            instanceCount: this.aggregatedMetrics.totalInstances\n        };\n    }\n    \n    /**\n     * Process new alert\n     */\n    async processAlert(alert) {\n        const existingAlert = this.activeAlerts.get(alert.id);\n        \n        if (!existingAlert) {\n            // New alert\n            this.activeAlerts.set(alert.id, alert);\n            this.alertHistory.push({...alert, action: 'triggered'});\n            \n            // Store alert in Redis\n            await this.storeAlert(alert);\n            \n            // Publish alert notification\n            await this.publishAlert(alert);\n            \n            console.log(`ðŸš¨ Alert triggered: ${alert.id} - ${alert.message}`);\n        } else {\n            // Update existing alert with new values\n            existingAlert.currentValue = alert.currentValue;\n            existingAlert.timestamp = alert.timestamp;\n        }\n    }\n    \n    /**\n     * Store alert in Redis\n     */\n    async storeAlert(alert) {\n        try {\n            const alertsData = await this.redisClient.hGetAll('metrics:alerts') || {};\n            const activeAlerts = JSON.parse(alertsData.activeAlerts || '[]');\n            \n            // Add new alert if not already present\n            if (!activeAlerts.find(a => a.id === alert.id)) {\n                activeAlerts.push(alert);\n            }\n            \n            await this.redisClient.hSet('metrics:alerts', {\n                activeAlerts: JSON.stringify(activeAlerts),\n                lastAlertCheck: Date.now().toString(),\n                totalAlertsTriggered: (parseInt(alertsData.totalAlertsTriggered || '0') + 1).toString()\n            });\n        } catch (err) {\n            console.error('Alert storage error:', err.message);\n        }\n    }\n    \n    /**\n     * Publish alert for real-time notifications\n     */\n    async publishAlert(alert) {\n        try {\n            const event = {\n                timestamp: Date.now(),\n                type: 'metrics_alert',\n                data: { alert }\n            };\n            \n            await this.redisClient.publish('cv:system:broadcast', JSON.stringify(event));\n        } catch (err) {\n            console.error('Alert publish error:', err.message);\n        }\n    }\n    \n    /**\n     * Clean up resolved alerts\n     */\n    cleanupResolvedAlerts() {\n        const metrics = this.aggregatedMetrics;\n        const resolvedAlerts = [];\n        \n        for (const [alertId, alert] of this.activeAlerts.entries()) {\n            let resolved = false;\n            \n            // Check if alert conditions are resolved\n            switch (alertId.split('_')[0]) {\n                case 'latency':\n                    resolved = metrics.avgLatency <= this.alertThresholds.latency.warning;\n                    break;\n                case 'memory':\n                    resolved = metrics.totalMemoryMB <= this.alertThresholds.memory.warning;\n                    break;\n                case 'success':\n                    resolved = metrics.overallSuccessRate >= this.alertThresholds.successRate.warning;\n                    break;\n            }\n            \n            if (resolved) {\n                resolvedAlerts.push(alertId);\n                this.alertHistory.push({...alert, action: 'resolved', resolvedAt: Date.now()});\n                console.log(`âœ… Alert resolved: ${alertId}`);\n            }\n        }\n        \n        // Remove resolved alerts\n        resolvedAlerts.forEach(alertId => this.activeAlerts.delete(alertId));\n        \n        // Update Redis if alerts were resolved\n        if (resolvedAlerts.length > 0) {\n            this.updateAlertsInRedis();\n        }\n    }\n    \n    /**\n     * Update alerts in Redis\n     */\n    async updateAlertsInRedis() {\n        try {\n            const activeAlerts = Array.from(this.activeAlerts.values());\n            \n            await this.redisClient.hSet('metrics:alerts', {\n                activeAlerts: JSON.stringify(activeAlerts),\n                lastAlertCheck: Date.now().toString()\n            });\n        } catch (err) {\n            console.error('Alerts Redis update error:', err.message);\n        }\n    }\n    \n    /**\n     * Clean up inactive instances\n     */\n    cleanupInactiveInstances() {\n        const now = Date.now();\n        const inactiveInstances = [];\n        \n        for (const [instanceId, lastActivity] of this.lastInstanceActivity.entries()) {\n            if (now - lastActivity > this.config.instanceTimeoutMs) {\n                inactiveInstances.push(instanceId);\n            }\n        }\n        \n        // Remove inactive instances\n        inactiveInstances.forEach(instanceId => {\n            this.activeInstances.delete(instanceId);\n            this.lastInstanceActivity.delete(instanceId);\n            this.instanceMetrics.delete(instanceId);\n        });\n        \n        if (inactiveInstances.length > 0) {\n            console.log(`ðŸ§¹ Cleaned up ${inactiveInstances.length} inactive instances`);\n        }\n    }\n    \n    /**\n     * Get current aggregation statistics\n     */\n    getStats() {\n        return {\n            aggregatedMetrics: this.aggregatedMetrics,\n            activeInstances: Array.from(this.activeInstances),\n            activeAlerts: Array.from(this.activeAlerts.values()),\n            alertHistory: this.alertHistory.slice(-20), // Last 20 alerts\n            instanceCount: this.activeInstances.size\n        };\n    }\n    \n    /**\n     * Get real-time aggregated metrics for API\n     */\n    async getAggregatedMetrics() {\n        try {\n            const redisMetrics = await this.redisClient.hGetAll('metrics:aggregated');\n            return {\n                ...redisMetrics,\n                activeInstances: JSON.parse(redisMetrics.activeInstances || '[]'),\n                lastUpdate: parseInt(redisMetrics.lastUpdate || '0')\n            };\n        } catch (err) {\n            console.error('Get aggregated metrics error:', err.message);\n            return this.aggregatedMetrics;\n        }\n    }\n    \n    /**\n     * Get current alerts\n     */\n    async getCurrentAlerts() {\n        try {\n            const alertsData = await this.redisClient.hGetAll('metrics:alerts');\n            return {\n                activeAlerts: JSON.parse(alertsData.activeAlerts || '[]'),\n                lastCheck: parseInt(alertsData.lastAlertCheck || '0'),\n                totalTriggered: parseInt(alertsData.totalAlertsTriggered || '0')\n            };\n        } catch (err) {\n            console.error('Get alerts error:', err.message);\n            return { activeAlerts: [], lastCheck: 0, totalTriggered: 0 };\n        }\n    }\n    \n    /**\n     * Update alert thresholds\n     */\n    updateAlertThresholds(newThresholds) {\n        this.alertThresholds = { ...this.alertThresholds, ...newThresholds };\n        console.log('ðŸ”§ Alert thresholds updated:', newThresholds);\n    }\n}\n\nmodule.exports = MetricsAggregator;