/**
 * Metrics Streamer - Real-time WebSocket metrics streaming for admin GUI
 * Provides efficient, throttled metrics updates to connected admin clients
 * 
 * Enhanced Claude Development Protocol v1.4 - Phase 1: Draft Implementation
 */

class MetricsStreamer {
    constructor(redisClient) {
        this.redisClient = redisClient;
        
        // Configuration
        this.config = {
            streamIntervalMs: 1000, // Stream updates every second
            throttleMs: 100, // Minimum time between messages to same client
            maxClientsPerStream: 50, // Prevent overwhelming with too many clients
            messageQueueSize: 100, // Max queued messages per client
            metricsRetentionMs: 300000 // Keep metrics for 5 minutes
        };\n        \n        // Client management\n        this.connectedClients = new Map(); // clientId -> client object\n        this.clientLastMessage = new Map(); // clientId -> timestamp\n        this.clientMessageQueues = new Map(); // clientId -> message queue\n        \n        // Metrics caching for efficient streaming\n        this.metricsCache = {\n            realtime: null,\n            aggregated: null,\n            alerts: null,\n            lastUpdate: 0\n        };\n        \n        // Streaming state\n        this.isStreaming = false;\n        this.streamingClients = 0;\n        \n        this.init();\n    }\n    \n    init() {\n        // Setup Redis subscriber for real-time metrics events\n        this.setupMetricsSubscriber();\n        \n        // Setup periodic metrics streaming\n        setInterval(() => {\n            this.streamMetrics();\n        }, this.config.streamIntervalMs);\n        \n        // Setup client cleanup\n        setInterval(() => {\n            this.cleanupDisconnectedClients();\n        }, this.config.metricsRetentionMs);\n        \n        console.log('ðŸ“¡ Metrics Streamer initialized');\n    }\n    \n    /**\n     * Setup Redis subscriber for metrics events\n     */\n    async setupMetricsSubscriber() {\n        try {\n            // Create subscriber client\n            this.redisSubscriber = this.redisClient.duplicate();\n            await this.redisSubscriber.connect();\n            \n            // Subscribe to metrics and alert events\n            await this.redisSubscriber.subscribe('cv:system:broadcast', (message) => {\n                this.handleMetricsEvent(JSON.parse(message));\n            });\n            \n            console.log('ðŸ“Š Metrics streamer subscribed to system broadcasts');\n        } catch (err) {\n            console.error('Metrics streamer subscriber setup error:', err.message);\n        }\n    }\n    \n    /**\n     * Handle incoming metrics events for real-time streaming\n     */\n    handleMetricsEvent(event) {\n        if (event.type === 'metrics_update') {\n            // Update metrics cache\n            this.updateMetricsCache();\n            \n            // Stream immediate update to connected clients\n            this.streamImmediateUpdate({\n                type: 'metrics_update',\n                data: event.data,\n                timestamp: event.timestamp\n            });\n        } else if (event.type === 'metrics_alert') {\n            // Stream alert immediately\n            this.streamImmediateUpdate({\n                type: 'metrics_alert',\n                alert: event.data.alert,\n                timestamp: event.timestamp\n            });\n        }\n    }\n    \n    /**\n     * Add new client connection\n     */\n    addClient(connection, clientId = null) {\n        const id = clientId || this.generateClientId();\n        \n        // Check client limit\n        if (this.connectedClients.size >= this.config.maxClientsPerStream) {\n            console.warn(`ðŸš« Max clients reached (${this.config.maxClientsPerStream}), rejecting connection`);\n            return false;\n        }\n        \n        const client = {\n            id,\n            connection,\n            connectedAt: Date.now(),\n            messagesSent: 0,\n            lastActivity: Date.now()\n        };\n        \n        this.connectedClients.set(id, client);\n        this.clientLastMessage.set(id, 0);\n        this.clientMessageQueues.set(id, []);\n        \n        // Setup connection event handlers\n        this.setupClientHandlers(client);\n        \n        // Send initial metrics state\n        this.sendInitialMetrics(client);\n        \n        this.streamingClients = this.connectedClients.size;\n        console.log(`ðŸ“± Client connected to metrics stream: ${id} (${this.streamingClients} total)`);\n        \n        return id;\n    }\n    \n    /**\n     * Setup client connection handlers\n     */\n    setupClientHandlers(client) {\n        const { connection, id } = client;\n        \n        // Handle connection close\n        connection.socket.on('close', () => {\n            this.removeClient(id);\n        });\n        \n        // Handle connection error\n        connection.socket.on('error', (err) => {\n            console.error(`Metrics client error ${id}:`, err.message);\n            this.removeClient(id);\n        });\n        \n        // Handle incoming messages (client configuration, etc.)\n        connection.socket.on('message', (message) => {\n            this.handleClientMessage(client, message);\n        });\n    }\n    \n    /**\n     * Handle messages from clients\n     */\n    handleClientMessage(client, message) {\n        try {\n            const data = JSON.parse(message.toString());\n            \n            switch (data.type) {\n                case 'metrics_config':\n                    // Client requesting specific metrics configuration\n                    this.updateClientConfig(client, data.config);\n                    break;\n                case 'ping':\n                    // Client keepalive\n                    client.lastActivity = Date.now();\n                    this.sendToClient(client, { type: 'pong', timestamp: Date.now() });\n                    break;\n                default:\n                    console.log(`Unknown message type from metrics client ${client.id}:`, data.type);\n            }\n        } catch (err) {\n            console.error(`Invalid message from metrics client ${client.id}:`, err.message);\n        }\n    }\n    \n    /**\n     * Remove client connection\n     */\n    removeClient(clientId) {\n        if (this.connectedClients.has(clientId)) {\n            this.connectedClients.delete(clientId);\n            this.clientLastMessage.delete(clientId);\n            this.clientMessageQueues.delete(clientId);\n            \n            this.streamingClients = this.connectedClients.size;\n            console.log(`ðŸ“± Client disconnected from metrics stream: ${clientId} (${this.streamingClients} remaining)`);\n        }\n    }\n    \n    /**\n     * Send initial metrics state to new client\n     */\n    async sendInitialMetrics(client) {\n        try {\n            // Load current metrics state\n            await this.updateMetricsCache();\n            \n            const initialState = {\n                type: 'metrics_initial_state',\n                data: {\n                    realtime: this.metricsCache.realtime,\n                    aggregated: this.metricsCache.aggregated,\n                    alerts: this.metricsCache.alerts,\n                    streamConfig: {\n                        updateInterval: this.config.streamIntervalMs,\n                        clientId: client.id\n                    }\n                },\n                timestamp: Date.now()\n            };\n            \n            this.sendToClient(client, initialState);\n        } catch (err) {\n            console.error('Error sending initial metrics:', err.message);\n        }\n    }\n    \n    /**\n     * Update metrics cache from Redis\n     */\n    async updateMetricsCache() {\n        try {\n            const [realtime, aggregated, alerts] = await Promise.all([\n                this.redisClient.hGetAll('metrics:realtime'),\n                this.redisClient.hGetAll('metrics:aggregated'),\n                this.redisClient.hGetAll('metrics:alerts')\n            ]);\n            \n            this.metricsCache = {\n                realtime: realtime || {},\n                aggregated: {\n                    ...aggregated,\n                    activeInstances: JSON.parse(aggregated.activeInstances || '[]')\n                },\n                alerts: {\n                    ...alerts,\n                    activeAlerts: JSON.parse(alerts.activeAlerts || '[]')\n                },\n                lastUpdate: Date.now()\n            };\n        } catch (err) {\n            console.error('Metrics cache update error:', err.message);\n        }\n    }\n    \n    /**\n     * Stream periodic metrics updates to all clients\n     */\n    async streamMetrics() {\n        if (this.connectedClients.size === 0) return;\n        \n        try {\n            // Update cache with latest metrics\n            await this.updateMetricsCache();\n            \n            const metricsUpdate = {\n                type: 'metrics_periodic_update',\n                data: {\n                    realtime: this.metricsCache.realtime,\n                    aggregated: this.metricsCache.aggregated,\n                    alerts: this.metricsCache.alerts\n                },\n                timestamp: Date.now()\n            };\n            \n            // Send to all connected clients (with throttling)\n            this.broadcastToClients(metricsUpdate);\n            \n        } catch (err) {\n            console.error('Metrics streaming error:', err.message);\n        }\n    }\n    \n    /**\n     * Stream immediate update to clients (for events)\n     */\n    streamImmediateUpdate(update) {\n        if (this.connectedClients.size === 0) return;\n        \n        this.broadcastToClients(update, true); // Skip throttling for immediate updates\n    }\n    \n    /**\n     * Broadcast message to all connected clients\n     */\n    broadcastToClients(message, skipThrottling = false) {\n        const now = Date.now();\n        \n        for (const client of this.connectedClients.values()) {\n            // Check throttling\n            if (!skipThrottling) {\n                const lastMessage = this.clientLastMessage.get(client.id);\n                if (now - lastMessage < this.config.throttleMs) {\n                    // Queue message for later\n                    this.queueMessageForClient(client.id, message);\n                    continue;\n                }\n            }\n            \n            this.sendToClient(client, message);\n            this.clientLastMessage.set(client.id, now);\n        }\n    }\n    \n    /**\n     * Queue message for throttled client\n     */\n    queueMessageForClient(clientId, message) {\n        const queue = this.clientMessageQueues.get(clientId);\n        if (!queue) return;\n        \n        queue.push(message);\n        \n        // Limit queue size\n        if (queue.length > this.config.messageQueueSize) {\n            queue.shift(); // Remove oldest message\n        }\n    }\n    \n    /**\n     * Process queued messages for clients\n     */\n    processQueuedMessages() {\n        const now = Date.now();\n        \n        for (const [clientId, queue] of this.clientMessageQueues.entries()) {\n            if (queue.length === 0) continue;\n            \n            const lastMessage = this.clientLastMessage.get(clientId);\n            if (now - lastMessage >= this.config.throttleMs) {\n                const client = this.connectedClients.get(clientId);\n                if (client) {\n                    const message = queue.shift();\n                    this.sendToClient(client, message);\n                    this.clientLastMessage.set(clientId, now);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Send message to specific client\n     */\n    sendToClient(client, message) {\n        try {\n            const data = JSON.stringify(message);\n            client.connection.send(data);\n            client.messagesSent++;\n            client.lastActivity = Date.now();\n        } catch (err) {\n            console.error(`Error sending to metrics client ${client.id}:`, err.message);\n            this.removeClient(client.id);\n        }\n    }\n    \n    /**\n     * Update client configuration\n     */\n    updateClientConfig(client, config) {\n        // Store client-specific configuration\n        client.config = { ...client.config, ...config };\n        \n        console.log(`ðŸ“± Updated config for client ${client.id}:`, config);\n        \n        // Send acknowledgment\n        this.sendToClient(client, {\n            type: 'config_updated',\n            config: client.config,\n            timestamp: Date.now()\n        });\n    }\n    \n    /**\n     * Clean up disconnected clients\n     */\n    cleanupDisconnectedClients() {\n        const now = Date.now();\n        const timeoutThreshold = now - this.config.metricsRetentionMs;\n        const disconnectedClients = [];\n        \n        for (const [clientId, client] of this.connectedClients.entries()) {\n            if (client.lastActivity < timeoutThreshold) {\n                disconnectedClients.push(clientId);\n            }\n        }\n        \n        disconnectedClients.forEach(clientId => {\n            this.removeClient(clientId);\n        });\n        \n        if (disconnectedClients.length > 0) {\n            console.log(`ðŸ§¹ Cleaned up ${disconnectedClients.length} inactive metrics clients`);\n        }\n    }\n    \n    /**\n     * Generate unique client ID\n     */\n    generateClientId() {\n        return `metrics-client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    /**\n     * Get streaming statistics\n     */\n    getStats() {\n        const clients = Array.from(this.connectedClients.values());\n        \n        return {\n            connectedClients: this.streamingClients,\n            totalMessagesSent: clients.reduce((sum, c) => sum + c.messagesSent, 0),\n            averageConnectionTime: clients.length > 0 \n                ? (Date.now() - clients.reduce((sum, c) => sum + c.connectedAt, 0) / clients.length) / 1000\n                : 0,\n            queuedMessages: Array.from(this.clientMessageQueues.values())\n                .reduce((sum, queue) => sum + queue.length, 0),\n            cacheLastUpdate: this.metricsCache.lastUpdate,\n            streamingActive: this.isStreaming\n        };\n    }\n    \n    /**\n     * Get connected clients info\n     */\n    getConnectedClients() {\n        return Array.from(this.connectedClients.values()).map(client => ({\n            id: client.id,\n            connectedAt: client.connectedAt,\n            messagesSent: client.messagesSent,\n            lastActivity: client.lastActivity,\n            queuedMessages: this.clientMessageQueues.get(client.id)?.length || 0\n        }));\n    }\n    \n    /**\n     * Emergency stop streaming\n     */\n    emergencyStop() {\n        console.log('ðŸš¨ Emergency stop - disconnecting all metrics clients');\n        \n        // Disconnect all clients\n        for (const client of this.connectedClients.values()) {\n            try {\n                client.connection.close();\n            } catch (err) {\n                // Ignore close errors\n            }\n        }\n        \n        // Clear all state\n        this.connectedClients.clear();\n        this.clientLastMessage.clear();\n        this.clientMessageQueues.clear();\n        this.streamingClients = 0;\n        this.isStreaming = false;\n    }\n    \n    /**\n     * Start streaming (if stopped)\n     */\n    startStreaming() {\n        this.isStreaming = true;\n        console.log('ðŸ“¡ Metrics streaming started');\n    }\n    \n    /**\n     * Stop streaming (keep connections)\n     */\n    stopStreaming() {\n        this.isStreaming = false;\n        console.log('ðŸ“¡ Metrics streaming stopped');\n    }\n}\n\nmodule.exports = MetricsStreamer;